# -*- coding: utf-8 -*-
"""Prompt_Foundry_New_Demo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18Cpsn-9b-H80TuyVRrxI77hcBNfP6Q5T
"""

!pip install openai==1.55.3 httpx==0.27.2 --force-reinstall --quiet

#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

!pip install PyGithub
!pip install docker

from string import ascii_lowercase
from github import Github
import openai
import os
import subprocess

# Replace with your actual OpenAI API key
def initialize_openai(api_key):
    """Initialize OpenAI with the API key."""
    openai.api_key = api_key

initialize_openai("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")

def get_openai_response(prompt, model="gpt-4"):
    """Get a response from OpenAI for a given prompt."""
    messages = [{"role": "user", "content": prompt}]
    response = openai.chat.completions.create(
        model=model,
        messages=messages,
        temperature=0
    )
    return response.choices[0].message.content

def analyze_requirements(user_input):
    """
    Analyze the user-provided description and extract the application type, resources,
    instance plans, hours of use, and cost reasoning.
    """
    prompt = f"""
    Analyze the following application description and provide:
    1. Type of application (e.g., web, mobile, API).
    2. Purpose of the application.
    3. Ideal Azure resources needed to deploy the application.
    4. Suggest the best Azure instance type (e.g., A1v2, A2v2, A4v2, etc.) for the application, considering its purpose,
       required resources, and potential workload. Provide a clear justification for your choice.
    5. Choose the optimal pricing model (pay_as_you_go, 1_year_reserved, or 3_year_reserved)
       based on the application's expected usage pattern and long-term needs. Explain your reasoning.
    6. Specify the number of hours the application is expected to run per month.
       If the description doesn't provide this information, make a reasonable estimate based on the application type and purpose.
       **Always provide this value as an integer.**

    Provide the instance type, pricing model, usage hours, and explain your choices clearly.

    Input:
    "{user_input}"
    """
    response = get_openai_response(prompt)

    # Ensure usage hours is an integer:
    lines = response.splitlines()
    for i, line in enumerate(lines):
        if "hours" in line.lower() and ":" in line:
            try:
                hours_value = line.split(":")[1].strip()
                # Try to extract a number, even if it's within text
                import re
                match = re.search(r'\d+', hours_value)
                if match:
                    hours_value = int(match.group())
                else:
                    # If no number found, provide a default (e.g., 730)
                    hours_value = 730
                lines[i] = line.split(":")[0] + ": " + str(hours_value)
                break
            except ValueError:
                pass

    return "\n".join(lines)

def generate_app_code(requirements):
    """Generate starter code for the application based on analyzed requirements."""
    prompt = f"""
    Generate starter code for the following application:
    {requirements}
    Ensure the code includes basic functionality and is deployable to GitHub.
    """
    return get_openai_response(prompt)

def containerize_app_code(requirements):
    """Generate Dockerfile and containerization scripts dynamically using OpenAI."""
    prompt = f"""
    Based on the following application requirements:
    {requirements}
    Generate a Dockerfile and a simple containerization script to run the application in a containerized environment.
    Ensure the Dockerfile follows best practices, installs dependencies, and sets up the application correctly.
    """
    return get_openai_response(prompt)


def generate_cloud_infra(resources):
    """Generate Terraform code for the cloud infrastructure based on identified resources."""
    prompt = f"""
    Generate Terraform code for the following Azure cloud resources:
    {resources}
    The code should be modular and follow best practices.
    """
    return get_openai_response(prompt)

def calculate_azure_cost(instance_type, usage_hours, pricing_model="pay_as_you_go"):
    """
    Calculate the Azure cost based on instance type, usage hours, and pricing model.

    :param instance_type: str, Type of Azure instance (e.g., "A1v2", "A2v2")
    :param usage_hours: int, Number of hours used per month (max 730 for full month)
    :param pricing_model: str, Pricing model ("pay_as_you_go", "1_year_reserved", "3_year_reserved")
    :return: float, Calculated cost for the selected instance and usage
    """
    # Example pricing data for Azure instances (this should match real Azure pricing for accuracy)
    instance_pricing = {
        "A1v2": {"pay_as_you_go": 39.42, "1_year_reserved": 49.08, "3_year_reserved": 43.58},
        "A2v2": {"pay_as_you_go": 82.49, "1_year_reserved": 99.74, "3_year_reserved": 88.13},
        "A4v2": {"pay_as_you_go": 173.74, "1_year_reserved": 202.82, "3_year_reserved": 178.43},
        # Add more instances with pricing here as needed
    }

    # Validate the input parameters
    if instance_type not in instance_pricing:
        raise ValueError(f"Invalid instance type: {instance_type}. Please select a valid instance.")
    if pricing_model not in instance_pricing[instance_type]:
        raise ValueError(f"Invalid pricing model: {pricing_model}. Please choose from 'pay_as_you_go', '1_year_reserved', or '3_year_reserved'.")
    if not (0 <= usage_hours <= 730):
        raise ValueError("Usage hours must be between 0 and 730.")

    # Retrieve the monthly price for the chosen instance type and pricing model
    monthly_price = instance_pricing[instance_type][pricing_model]

    # Calculate the hourly cost
    cost_per_hour = monthly_price / 730  # Assuming 730 hours in a month (30.42 days)

    # Calculate the total cost based on usage hours
    total_cost = cost_per_hour * usage_hours

    # Return the total cost rounded to 2 decimal places
    return round(total_cost, 2)


def deploy_to_github(repo_name, files):
    """Deploy generated code to GitHub."""
    g = Github("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")
    user = g.get_user()
    repo = user.create_repo(repo_name)
    for file_name, file_content in files.items():
        repo.create_file(file_name, f"Add {file_name}", file_content)
    return repo.clone_url

def mock_deploy_infra(resources, instance_details, cost_estimate):
    """Mock deployment step: Print resource deployment details with OpenAI-determined instances and costs."""
    print("\nDeploying the following resources to HashiCorp Cloud Platform (HCP):")
    for resource in resources.splitlines():
        print(f"- {resource.strip()}")
    print(f"\nInstance Details: {instance_details}")
    print(f"Estimated Monthly Cost: {cost_estimate}")
    print("\nDeployment complete!")

def main():
    print("Welcome to the Application and Infrastructure Generator!")

    # Step 1: Gather user input (large text description)
    print("\nProvide a detailed description of your application requirements.")
    user_input = input("Description: ")

    # Step 2: Analyze requirements using OpenAI
    print("\nAnalyzing your requirements...")
    requirements = analyze_requirements(user_input)
    print("\nRequirements Analysis:")
    print(requirements)

    # Extract instance details, pricing model, and hours
    lines = requirements.splitlines()
    instance_type = next((line.split(":")[1].strip() for line in lines if "instance type" in line.lower()), "A1v2")
    pricing_model = next((line.split(":")[1].strip() for line in lines if "pricing model" in line.lower()), "pay_as_you_go")
    usage_hours = int(next((line.split(":")[1].strip() for line in lines if "hours" in line.lower()), 730))

    # Reasoning from OpenAI
    reasoning = "\n".join([line for line in lines if "reasoning" in line.lower()])
    print(f"\nOpenAI Reasoning for Cost Parameters:\n{reasoning}")

    # Calculate cost dynamically
    try:
        cost_estimate = calculate_azure_cost(instance_type, usage_hours, pricing_model)
        cost_estimate_str = f"${cost_estimate:.2f}"
    except ValueError as e:
        print(f"Error calculating cost: {e}")
        cost_estimate_str = "Cost calculation failed."
    # Extract resources, instance details, and cost
    lines = requirements.splitlines()
    resources = "\n".join([line for line in lines if "resources" in line.lower()])
    instance_details = next((line for line in lines if "instance types" in line.lower()), "Not Specified")
    cost_estimate = next((line for line in lines if "cost" in line.lower()), "Cost not provided")

    # Step 3: Generate application code
    print("\nGenerating application code...")
    app_code = generate_app_code(requirements)
    print("Application code generated.")

    # Step 4: Containerize the application (mock step)
    print("\nContainerizing the application...")
    docker_code = containerize_app_code(requirements)

    # Step 5: Generate cloud infrastructure
    print("\nGenerating cloud infrastructure code...")
    terraform_code = generate_cloud_infra(resources)
    print("Cloud infrastructure code generated.")

    # Step 6: Deploy code to GitHub
    print("\nDeploying application and infrastructure code to GitHub...")
    repo_name = input("Enter a name for your GitHub repository: ")
    files = {
        "app_code.py": app_code,
        "Dockerfile": docker_code,
        "infra/main.tf": terraform_code
    }
    repo_url = deploy_to_github(repo_name, files)
    print(f"Code deployed to GitHub: {repo_url}")

    # Step 7: Mock infrastructure deployment
    deploy_infra = input("\nDo you want to deploy the infrastructure to HCP? (yes/no): ").strip().lower()
    if deploy_infra == "yes":
        mock_deploy_infra(resources, instance_details, cost_estimate)
    else:
        print("\nInfrastructure deployment canceled.")

if __name__ == "__main__":
    main()



from github import Github
import openai
import re


def initialize_openai(api_key):
    """Initialize OpenAI with the API key."""
    openai.api_key = api_key


initialize_openai("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")

def get_openai_response(prompt, model="gpt-4"):
    """Get a response from OpenAI for a given prompt."""
    messages = [{"role": "user", "content": prompt}]
    response = openai.chat.completions.create(
        model=model,
        messages=messages,
        temperature=0
    )
    return response.choices[0].message.content

def analyze_requirements(user_input):
    """
    Analyze the user-provided description and extract application type, resources,
    instance plans, hours of use, and cost reasoning.
    """
    prompt = f"""
    Analyze the following application description and provide:
    1. Type of application (e.g., web, mobile, API).
    2. Purpose of the application.
    3. Ideal Azure resources needed to deploy the application.
    4. Suggest the best Azure instance type (A1v2, A2v2, or A4v2) for the application, considering its purpose,
       required resources, and potential workload. Provide only the instance type, nothing else.
    5. Choose the optimal pricing model (pay_as_you_go, 1_year_reserved, or 3_year_reserved)
       based on the application's expected usage pattern and long-term needs. Provide only the pricing model, nothing else.
    6. Specify the number of hours the application is expected to run per month.
       If the description doesn't provide this information, make a reasonable estimate based on the application type and purpose.
       **Always provide this value as an integer.**
    Input:
    "{user_input}"
    """
    return get_openai_response(prompt)

def generate_app_code(requirements, language="Python"):
    """Generate detailed application code based on analyzed requirements."""
    prompt = f"""
    Based on the following requirements:
    {requirements}
    Generate detailed starter code for the application in {language}. Include:
    1. Proper project structure.
    2. Clear comments for each function.
    3. Error handling mechanisms.
    Ensure the code is production-ready and follows best practices in {language}.
    """
    return get_openai_response(prompt)

def generate_containerization_code(requirements):
    """Generate a detailed Dockerfile and containerization script."""
    prompt = f"""
    Based on the following application requirements:
    {requirements}
    Generate:
    1. A Dockerfile that:
        - Follows best practices.
        - Installs dependencies.
        - Exposes necessary ports.
        - Uses multi-stage builds if appropriate.
    2. A containerization script to build and run the Docker container.
    """
    return get_openai_response(prompt)

def generate_terraform_code(resources):
    """Generate detailed Terraform code for Azure infrastructure."""
    prompt = f"""
    Based on the following Azure resources:
    {resources}
    Generate Terraform code that:
    1. Is modular and scalable.
    2. Includes variable files for configurations.
    3. Properly sets up the required resources with outputs for resource IDs and endpoints.
    """
    return get_openai_response(prompt)

def extract_value(lines, keyword, valid_values=None, default=None):
    """
    Extract a value from lines based on a keyword.
    """
    for line in lines:
        if keyword.lower() in line.lower():
            match = re.search(r'({})'.format('|'.join(valid_values)), line)
            if match:
                return match.group(1)
    return default

def calculate_azure_cost(instance_type, usage_hours, pricing_model="pay_as_you_go"):
    """
    Calculate the Azure cost based on instance type, usage hours, and pricing model.
    """
    instance_pricing = {
        "A1v2": {"pay_as_you_go": 39.42, "1_year_reserved": 49.08, "3_year_reserved": 43.58},
        "A2v2": {"pay_as_you_go": 82.49, "1_year_reserved": 99.74, "3_year_reserved": 88.13},
        "A4v2": {"pay_as_you_go": 173.74, "1_year_reserved": 202.82, "3_year_reserved": 178.43},
    }

    if instance_type not in instance_pricing:
        raise ValueError(f"Invalid instance type: {instance_type}. Please select one of: A1v2, A2v2, A4v2.")
    if pricing_model not in instance_pricing[instance_type]:
        raise ValueError(f"Invalid pricing model: {pricing_model}. Please select one of: pay_as_you_go, 1_year_reserved, 3_year_reserved.")

    monthly_price = instance_pricing[instance_type][pricing_model]
    cost_per_hour = monthly_price / 730
    total_cost = round(cost_per_hour * usage_hours, 2)
    return total_cost

def deploy_to_github(repo_name, files):
    """Deploy generated code to GitHub."""
    g = Github("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")
    user = g.get_user()
    repo = user.create_repo(repo_name)
    for file_name, file_content in files.items():
        repo.create_file(file_name, f"Add {file_name}", file_content)
    return repo.clone_url

def main():
    print("Welcome to the Application and Infrastructure Generator!")

    # Step 1: Gather user input
    user_input = input("Provide a detailed description of your application requirements:\n")
    language = input("Enter the desired programming language for the application code (default: Python):\n") or "Python"

    # Step 2: Analyze requirements
    print("\nAnalyzing your requirements...")
    requirements = analyze_requirements(user_input)
    print("\nRequirements Analysis:\n", requirements)

    # Parse analysis results
    lines = requirements.splitlines()
    instance_type = extract_value(lines, "instance type", {"A1v2", "A2v2", "A4v2"}, "A1v2")
    pricing_model = extract_value(lines, "pricing model", {"pay_as_you_go", "1_year_reserved", "3_year_reserved"}, "pay_as_you_go")
    usage_hours = extract_value(lines, "hours", default=730)
    resources = "\n".join([line for line in lines if "resources" in line.lower()])

    # Step 3: Calculate Azure cost
    print("\nCalculating Azure cost...")
    try:
        cost_estimate = calculate_azure_cost(instance_type, int(usage_hours), pricing_model)
        print(f"Estimated Monthly Cost: ${cost_estimate:.2f}")
    except ValueError as e:
        print(f"Error in cost calculation: {e}")
        return

    # Step 4: Generate application code
    print(f"\nGenerating application code in {language}...")
    app_code = generate_app_code(requirements, language)
    print("\nApplication Code:\n", app_code)

    # Step 5: Generate containerization code
    print("\nGenerating containerization code...")
    container_code = generate_containerization_code(requirements)
    print("\nContainerization Code:\n", container_code)

    # Step 6: Generate Terraform code
    print("\nGenerating Terraform code...")
    terraform_code = generate_terraform_code(resources)
    print("\nTerraform Code:\n", terraform_code)

    # Step 7: Deploy code to GitHub
    print("\nPreparing to deploy code to GitHub...")
    repo_name = input("Enter a name for your GitHub repository: ")
    files = {
        f"app_code.{language.lower()}": app_code,
        "Dockerfile": container_code,
        "infra/main.tf": terraform_code
    }
    try:
        repo_url = deploy_to_github(repo_name, files)
        print(f"Code deployed to GitHub: {repo_url}")
    except Exception as e:
        print(f"Error deploying to GitHub: {e}")
        return

    print("\nDeployment process completed.")

if __name__ == "__main__":
    main()

from github import Github
import openai
import re
from IPython.display import display, Markdown, Code


def initialize_openai(api_key):
    """Initialize OpenAI with the API key."""
    openai.api_key = api_key


initialize_openai("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")


def get_openai_response(prompt, model="gpt-4"):
    """Get a response from OpenAI for a given prompt."""
    messages = [{"role": "user", "content": prompt}]
    response = openai.chat.completions.create(
        model=model,
        messages=messages,
        temperature=0
    )
    return response.choices[0].message.content


def analyze_requirements(user_input):
    """
    Analyze the user-provided description and extract application type, resources,
    instance plans, hours of use, and cost reasoning.
    """
    prompt = f"""
    Analyze the following application description and provide:
    1. Type of application (e.g., web, mobile, API).
    2. Purpose of the application.
    3. Ideal Azure resources needed to deploy the application.
    4. Suggest the best Azure instance type (A1v2, A2v2, or A4v2) for the application, considering its purpose,
       required resources, and potential workload. Provide only the instance type, nothing else.
    5. Choose the optimal pricing model (pay_as_you_go, 1_year_reserved, or 3_year_reserved)
       based on the application's expected usage pattern and long-term needs. Provide only the pricing model, nothing else.
    6. Specify the number of hours the application is expected to run per month.
       If the description doesn't provide this information, make a reasonable estimate based on the application type and purpose.
       **Always provide this value as an integer.**
    Input:
    "{user_input}"
    """
    return get_openai_response(prompt)


def generate_app_code(requirements, language="Python"):
    """Generate detailed application code based on analyzed requirements."""
    prompt = f"""
    Based on the following requirements:
    {requirements}
    Generate detailed starter code for the application in {language}. Include:
    1. Proper project structure.
    2. Clear comments for each function.
    3. Error handling mechanisms.
    Ensure the code is production-ready and follows best practices in {language}.
    """
    return get_openai_response(prompt)


def generate_containerization_code(requirements):
    """Generate a detailed Dockerfile and containerization script."""
    prompt = f"""
    Based on the following application requirements:
    {requirements}
    Generate:
    1. A Dockerfile that:
        - Follows best practices.
        - Installs dependencies.
        - Exposes necessary ports.
        - Uses multi-stage builds if appropriate.
    2. A containerization script to build and run the Docker container.
    """
    return get_openai_response(prompt)


def generate_terraform_code(resources):
    """Generate detailed Terraform code for Azure infrastructure."""
    prompt = f"""
    Based on the following Azure resources:
    {resources}
    Generate Terraform code that:
    1. Is modular and scalable.
    2. Includes variable files for configurations.
    3. Properly sets up the required resources with outputs for resource IDs and endpoints.
    """
    return get_openai_response(prompt)


def extract_value(lines, keyword, valid_values=None, default=None):
    """
    Extract a value from lines based on a keyword.
    """
    for line in lines:
        if keyword.lower() in line.lower():
            match = re.search(r'({})'.format('|'.join(valid_values)), line)
            if match:
                return match.group(1)
    return default


def calculate_azure_cost(instance_type, usage_hours, pricing_model="pay_as_you_go"):
    """
    Calculate the Azure cost based on instance type, usage hours, and pricing model.
    """
    instance_pricing = {
        "A1v2": {"pay_as_you_go": 39.42, "1_year_reserved": 49.08, "3_year_reserved": 43.58},
        "A2v2": {"pay_as_you_go": 82.49, "1_year_reserved": 99.74, "3_year_reserved": 88.13},
        "A4v2": {"pay_as_you_go": 173.74, "1_year_reserved": 202.82, "3_year_reserved": 178.43},
    }

    if instance_type not in instance_pricing:
        raise ValueError(f"Invalid instance type: {instance_type}. Please select one of: A1v2, A2v2, A4v2.")
    if pricing_model not in instance_pricing[instance_type]:
        raise ValueError(f"Invalid pricing model: {pricing_model}. Please select one of: pay_as_you_go, 1_year_reserved, 3_year_reserved.")

    monthly_price = instance_pricing[instance_type][pricing_model]
    cost_per_hour = monthly_price / 730
    total_cost = round(cost_per_hour * usage_hours, 2)
    return total_cost


def deploy_to_github(repo_name, files):
    """Deploy generated code to GitHub."""
    g = Github("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")
    user = g.get_user()
    repo = user.create_repo(repo_name)
    for file_name, file_content in files.items():
        repo.create_file(file_name, f"Add {file_name}", file_content)
    return repo.clone_url


def display_markdown(title, content):
    """Display content with Markdown styling."""
    display(Markdown(f"## {title}"))
    display(Markdown(content))

def display_code(title, code, language="text"):
    """Display code snippets with syntax highlighting."""
    # Map common misused aliases to correct ones
    language_alias_map = {
        "node.js": "javascript",
        "python3": "python",
    }
    language = language_alias_map.get(language.lower(), language.lower())

    display(Markdown(f"### {title}"))
    try:
        # Display the code snippet with proper syntax highlighting
        display(Code(data=code, language=language))
    except Exception as e:
        # Fallback: Display as plain text if an error occurs
        display(Markdown(f"Error displaying code with syntax highlighting: {str(e)}"))
        display(Markdown(f"```\n{code}\n```"))



def main():
    print("Welcome to the Application and Infrastructure Generator!")

    # Step 1: Gather user input
    user_input = input("Provide a detailed description of your application requirements:\n")
    language = input("Enter the desired programming language for the application code (default: Python):\n") or "Python"

    # Step 2: Analyze requirements
    print("\nAnalyzing your requirements...")
    requirements = analyze_requirements(user_input)
    display_markdown("Requirements Analysis", requirements)

    # Parse analysis results
    lines = requirements.splitlines()
    instance_type = extract_value(lines, "instance type", {"A1v2", "A2v2", "A4v2"}, "A1v2")
    pricing_model = extract_value(lines, "pricing model", {"pay_as_you_go", "1_year_reserved", "3_year_reserved"}, "pay_as_you_go")
    usage_hours = extract_value(lines, "hours", default=730)
    resources = "\n".join([line for line in lines if "resources" in line.lower()])

    # Step 3: Calculate Azure cost
    print("\nCalculating Azure cost...")
    try:
        cost_estimate = calculate_azure_cost(instance_type, int(usage_hours), pricing_model)
        display_markdown("Azure Cost Calculation", f"""
        - **Instance Type:** {instance_type}
        - **Pricing Model:** {pricing_model}
        - **Usage Hours:** {usage_hours}
        - **Estimated Monthly Cost:** ${cost_estimate:.2f}
        """)
    except ValueError as e:
        display_markdown("Error in Cost Calculation", str(e))
        return

    # Step 4: Generate application code
    print(f"\nGenerating application code in {language}...")
    app_code = generate_app_code(requirements, language)
    display_code("Generated Application Code", app_code, language.lower())

    # Step 5: Generate containerization code
    print("\nGenerating containerization code...")
    container_code = generate_containerization_code(requirements)
    display_code("Generated Containerization Code", container_code)

    # Step 6: Generate Terraform code
    print("\nGenerating Terraform code...")
    terraform_code = generate_terraform_code(resources)
    display_code("Generated Terraform Code", terraform_code, "terraform")

    # Step 7: Deploy code to GitHub
    print("\nPreparing to deploy code to GitHub...")
    repo_name = input("Enter a name for your GitHub repository: ")
    files = {
        f"app_code.{language.lower()}": app_code,
        "Dockerfile": container_code,
        "infra/main.tf": terraform_code
    }
    try:
        repo_url = deploy_to_github(repo_name, files)
        display_markdown("GitHub Deployment", f"Code deployed to GitHub: [View Repository]({repo_url})")
    except Exception as e:
        display_markdown("Error Deploying to GitHub", str(e))
        return

    print("\nDeployment process completed.")


if __name__ == "__main__":
    main()